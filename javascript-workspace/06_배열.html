<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area{
            width: 300px;
            border: 1px solid pink;
        }

        .small{
            height: 100px;
        }

        .big{
            height: 200px;
        }

    </style>
</head>
<body>
    <h1>배열</h1>
    <p>
        자바스크립트에서는 변수 선언시 별도의 자료형 지정이 없기 때문에<br>
        어떤 자료형의 값들이든지 다 하나의 배열공간에 담을 수 있음(자바의 컬렉션과 유사)
    </p>

    <button onclick="arrayTest1();">확인</button>
    <div id="area1" class="area small"></div>
    
    <script>
        function arrayTest1(){
            let arr = ["홍길동", "서울", "20", "true", [1,2,3]];
            arr.newKey="배열에다가 새로운 키 값 추가";

            console.log(arr);
            console.log(arr[2]);
            console.log(arr[4]);
            console.log(arr[4][0]);

            let area1=document.getElementById("area1");

           // for(let i=0; i<arr.length; i++){
           //     area1.innerHTML += arr[i]+"<br>"
           // }

            //향상된 반복문
            //배열의 0번째 인덱스부터 마지막인덱스까지 단순하게 순차적으로 접근할 목적이라면
            //for of, for in문 활용 가능
            //배열을 반복시키고자 한다면 for of => 0번부터~ 입력한 인덱스까지만 출력
            //객체를 반복시키고자 한다면 for in => 객체의 모든 key값에 접근하기 때문에

            //for(  let 변수명   of/in  반복을 시킬 배열/객체  );
            //for(let item of arr){
            //    area1.innerHTML+= item+"<br>";
            //}

            for(let i in arr){
                area1.innerHTML+= arr[i]+"<br>";
            }

            //배열의 0~n번째 인덱스에 있는 값들만 반복함 => for of
            //배열의 모든 key값을 순차적으로 반복함      => for in
            
         }

        

    </script>

    <hr>

    <h3>* 배열의 선언</h3>
    <p>
        배열 선언시 배열의 크기를 지정한 채로 선언하거나, 크기를 지정하지 않아도 됨(배열의 크기에 제약이 없다.)
    </p>

    <button onclick="arrayTest2();" >확인하기</button>
    <script>
        function arrayTest2(){
            //배열의 선언
            let arr1=[]; //배열의 크기가 0인 빈 배열 선언
            let arr2=new Array(); // 배열의 크기가 0인 빈 배열 선언
            let arr3=new Array(3);// 배열의 크기가 3인 빈 배열 선언

            console.log(arr1);
            console.log(arr2);
            console.log(arr3);


            //배열에 값 대입
            arr1[0]="바나나";
            arr1[1]="사과";
            arr1[10]="키위";

            console.log(arr1); //배열의 크기 11로 늘어나 있음, ([2]~[9]까지는 빈값으로 추가됨)

            arr3[0]="자동차";
            arr3[1]="기차";
            arr3[2]="도보";

            arr3[3]="비행기"; //배열의 크기 4로 늘어나있음. -> 처음에 선언한 배열의 크기가 상관이 없음

            console.log(arr3);

            //배열 선언과 동시에 초기화
            let arr4 = new Array("홍길동","임꺽정");
            let arr5 = ["자바","오라클","스프링"]; //-> 방법 선호

            console.log(arr4);
            console.log(arr5);
        }
    </script>

    <hr>

    <h3>*Array객체의 메서드</h3>
    <h4>
        1) indexOf(찾고자 하는 요소) <br>
        배열에서 해당 요소가 위치해 있는 인덱스를 반환
    </h4>

    <div ie="area2" class="area small"></div>
    <button onclick="indexOfTest();">확인</button>
    <script>
        function indexOfTest(){
            let area2 = document.getElementById("area2"); //div요소를 가지고 와서 area2에저장

            let arr=["사과","딸기","복숭아","샤인머스켓","파인애플"];
            let fruit = prompt("찾고자 하는 과일명을 입력하시오.");

            let index = arr.indexOf(fruit);
            //배열에 존재하지 않는 요소를 입력시 -1을 반환.

            console.log(index);

            //찾고자하는 과일이 있을 경우 : 당신이 찾는 과일 xxx는 x번째 인덱스에있습니다.
            //찾고자하는 과일이 없을 경우 : 당신이 찾는 과일 xxx는 판매하지 않습니다.

            area2.innerHTML = "당신이 찾는 과일"+fruit+"는 "
            if(index == -1){
                area2.innerHTML += "판매하지 않습니다.";
            }else{
                area2.innerHTML += index+"번째 인덱스에 있습니다.";
            }


            console.log(1==1); //true
            console.log(1 == "1"); //true => 동등연산자 : 자료형과 무관하게 실제 값만 일치하면 true
            console.log(1==="1"); //false => 일치연산자 : 값+자료형이 모두 일치해야 true 값을 반환
        }
    </script>

    <hr>
    <h4> 2)concat(배열, 배열,....) : 여러개의 배열을 결합하고자 할때 사용</h4>
    
    <div id="area3" class="area big"></div>
    <button onclick="concatTest();">확인하기</button>
    <script>
        let d= document;
        function concatTest(){
            let are3=d.getElementById("area3");

            let arr1=["사과","딸기"];
            let arr2=["자동차","비행기","지하철"];

            area3.innerHTML += "arr1 : "+arr1+"<br>";
            area3.innerHTML += `arr2 : ${arr2} <br>`;

            area3.innerHTML += "arr1 기준으로 배열 합치기 : " +arr1.concat(arr2)+"<br>";
            area3.innerHTML += "다시 arr1: "+arr1+"<br>";
            //concat : 원본배열에 영향을 끼치지 않는 메소드
            //두개의 배열을 합쳐서 새로운 배열 반환

            area3.innerHTML += "여러개의 배열을 합치기 : "+arr1.concat(arr2,[1,2,3],["삼겹살","갈매기살"]);

        }
    </script>

    <hr>

    <h4>3) reverse() : 배열에 담긴 값들을 역순으로 바꿔주는 메소드</h4>

    <div id="area4" class="area small"></div>
    <button onclick="reverseTest();">확인하기</button>
    <script>
        function reverseTest(){
            let area4 = d.getElementById("area4");
            let arr=[1,2,3,4,5];
            area4.innerHTML += "arr : "+arr+"<br>";
            area4.innerHTML += "reverse 결과: "+arr.reverse()+"<br>";
            area4.innerHTML += "원본 arr: "+arr+"<br>";
            //reverse : 원본배열에 영향을 끼치는 메서드.

        }

    </script>

    <hr>
    <h4>4) sort : 배열안에 담긴 값들을 오름차순으로 정렬시켜주는 메소드</h4>
    <div id="area5" class="area small"></div>
    <button onclick="sortTest();">확인하기</button>
    <script>
        function sortTest(){
            let area5 = d.getElementById("area5");

            let arr = ["김예진","기메징","기메진","김녜진","김예딩"];
            
            area5.innerHTML += "arr : " +arr+"<br>";
            area5.innerHTML += "sort 결과 : "+arr.sort() +"<br>";
            area5.innerHTML += "다시 arr : "+arr+"<br>";
            //sort : 원본배열에 영향을 끼치는 메소드

            //내림차순으로 정렬하고 싶다면 => 오름차순으로 정렬 후 , 역순으로 뒤집기
            area5.innerHTML += "내림차순 정렬 : "+arr.sort().reverse()+"<br>";

            //특이케이스
            let arr2 =[1,2,15];
            console.log(arr2.sort());
            //sort라는 함수 실행시 배열의 각 요소를 "문자열"로 취급하여 정렬하기 때문에
            //문자열 기준으로 오름차순 정렬됨.
            //"가가" < "나"
            //"19" < "2" => 19가 더 크려면 앞자리가 2보다 더 커야 함.

            //배열안에 객체가 담겨 있는 경우 기존 정렬기준 대신, 새로운 정렬기준을 만들어야 한다.
            //1)정렬기준을 새로 만들기
            function compare(a,b){
                if(a>b) return 1;   //첫번째 요소가 두번째 요소보다 큰 경우
                if(a==b) return 0;  //첫번째 요소가 두번째 요소와  같은 경우
                if(a <b) return -1; //첫번째 요소가 두번째 요소보다 작은 경우
            }

            //2) sort메소드 호출시 매개변수로 내가 만든 정렬 기준을 추가한다.
            console.log(arr2.sort(compare));

            //2-1)그외 방법
            console.log(arr2.sort(function(a,b) {return a-b}));
            //오름차순 정렬하는 정렬기준을 매개변수에 직접 함수로 추가.
            //return 값이 양수 반환시 -> 크다, 음수 반환시 -> 작다로 해석하여 정렬함.

            console.log(arr2.sort( (a,b) => a-b ));
        }
    </script>

    <hr>
    <h4> 5_1) push(추가할 요소) : 배열의 맨 뒤에 요소를 추가하고 배열의 크기 반환 <br>
         5_2) pop() : 배열의 맨 뒤 요소를 제거하고 제거된 요소를 반환
    </h4>

    <div id="area6" class="big area"></div>
    <button onclick="puShPoPTest();">확인</button>

    <script>
        function puShPoPTest(){
            let area6 = d.getElementById("area6");
            let arr = ["서초동","방배동","역삼동","삼성동","대치동"];

            area6.innerHTML += "arr : "+arr+"<br>";
            arr.push("신사동"); //배열의 맨뒤에 값 추기
            area6.innerHTML += "arr에 push후 "+arr+"<br>";
            area6.innerHTML += "arr에 push후 배열의 크기는 : "+arr.push("논현동")+"<br>";
            area6.innerHTML += "원본 arr: "+arr+"<br>";

            area6.innerHTML += "arr에 pop후 : "+arr.pop() +"<br>";
            area6.innerHTML += "원본 ARR : "+arr+"<br>;"

            //pop , push : 원본배열에 영향을 끼치는 메소드
            arr.pop();
            arr.pop();
            arr.pop();
            area6.innerHTML += "최종 arr: "+arr+"<br>";

            arr[5] = "dd"; //이렇게도 값을 추가할 수 있음.
            console.log(arr.length);
            arr.pop();
            arr.pop();
            arr.pop();
            console.log(arr);
        }
    </script>

    <hr>
    <h4>
        6_1)unshift(추가할 요소): 배열의 맨 앞에 요소 추가 후 배열의 크기 반환 <br>
        6_2)shift(추가할 요소)  : 배열의 맨 앞 요소 제거하고 제거된 요소 반환
    </h4>

    <div id="area7" class="area big"></div>
    <button onclick="shiftTest();">확인</button>
    <script>
        function shiftTest(){
            let area7 = d.querySelector("#area7");

            let arr = ["야구","볼링","테니스","탁구"];
            
            area7.innerHTML+= "arr : "+arr+"<br>";
            arr.unshift("농구");
            area7.innerHTML += "arr에 unshift함수 사용 후 : "+arr+"<br>";


            area7.innerHTML += "arr에 shift사용 후 : "+arr.shift()+"<br>";
            area7.innerHTML += "최종 arr : "+arr+"<br>";

        }
    </script>

    <hr>
    <h4>
        7_1) slice(시작, 끝) : 배열 안의 요소들을 단지 추출해주는 메소드<br>
        7_2) splice(시작, 제거할 개수, 추가값) : 배열의 요소를 추출해서 제거 및 추가, 추가값은 생략 가능
    </h4>

    <div id="area8" class="area small"></div>
    <button onclick="sliceTest();">확인</button>
    <script>
        function sliceTest(){
            let area8 = document.getElementById("area8");

            let arr = ["자바", "오라클","html","css","javascript"];
            area8.innerHTML += "arr : "+arr+"<br>";

            //slice(시작인덱스, 끝인덱스) => 끝 인덱스는 추출할 요소에 포함되지 않는다.
            area8.innerHTML += "slice 결과 : "+arr.slice(2,4)+"<br>"; // 2,3번인덱스 추출
            area8.innerHTML += "원본 arr : "+arr+"<br>";
            //slice : 원본배열에 영향을 끼치지 않음

            //splice(시작인덱스, 제거수, 추가할 요소)
            area8.innerHTML += "splice 결과 : " + arr.splice(2,2)+"<br>"; //2,3번 인덱스 제거
            area8.innerHTML += "원본 arr : " +arr+"<br>";
            //splice : 원본배열에 영향을 끼침.
        }

    </script>

    <hr>
    <h4>8)join([구분자]) /toString() : 배열에 담긴 값들을 하나의 문자열로 합쳐서 반환해주는 메소드</h4>
    <button onclick="toStringTest();">확인</button>
    <script>
        function toStringTest(){
            let arr=["나는","오늘부터","다이어트를","시작한다"];
            console.log(arr);
            console.log(arr.toString());
            //배열 객체를 html요소에 출력할 경우 내부적으로 .toString()호출 후 돌아온 결과 출력

            console.log(arr.join());
            //join은 기본적으로 ,를 통해 하나의 문자열로 합친다면
            //join메소드 호출시 구분자를 제시하면 해당구분자를 기준으로 하나의 문자열로 합쳐진다.
            
            console.log(arr.join(" "));

            //값자체에 join기능을 할당시킴
            console.log("나는,오늘부터,살찐다!".split(","));

            console.log([1,2,3,4,5].join("^"));
        }
    </script>

    <hr>
    <h4>9) 배열 반복문 </h4>
    <script>
        let arr =["소금","삼겹살","후추","쌈장"];

        //향상된 반복문 (for of)
        for( let food of arr ){
            console.log(food);
        }

        //배열을 통째로 비우는 방법
        arr.length =0;
        console.log(arr);

        let arr2 = [1,2,3,4,5];

        console.log(arr2);
        arr2.length=2; //length만큼 선언한 길이만큼 비워져 있음
        console.log(arr2);
    </script>

    <hr>

    <h4>10) 배열을 통한 반복 작업(forEach)</h4>
    <button onclick="foreachTest();">확인</button>
    <script>
        function foreachTest(){
            let a = [1,2,3,4,5];

            //item(첫번째 파라미터)  : 현재 반복을 진행중인 요소
            //index(두번째 파라미터) : 현재 반복을 진행중인 순서(인덱스)
            //array(세번째 파라미터) : 반복을 하고 있는 배열(a)
            a.forEach(function(item, index, array){
                console.log(`${item}은 ${array}배열의 ${index}에 위치해 있습니다.`);
            })

            //forEach구문안에 실행시킬 함수를 추가하기
            a.forEach(testAlert);
            a.forEach(function(text){
                alert(text);
            })
            //alert("출력할 문자"); --> item자리에 있는 1,2,3,4,5가 출력

            //alert
            //a.forEach(function alert(text)) { text에 들어가는 값은 배열의 반복중인 요소가 들어감
            //
            //}
            /*
                function alert(text){
                    text내용을 팝업창에 출력
                }
            */
        }
        function testAlert(text){
            alert(text);
        }

    </script>

    <hr>
    <h4>13)배열 탐색(find, filter)</h4>
    <p>
        객체로 이루어진 배열에서 내가 원하는 값을 찾을 때 사용
    </p>

    <button onclick="findTest();">확인</button>
    <script>
        function findTest(){
            let a=[
                {id:'rlapwls', name:'예진'},
                {id:'rlapwls2', name:'예진'},
                {id:'rlapwls3', name:'예진'},
                {id:'rlapwls4', name:'예진'},
            ]

            let boolean;

            //내가 원하는 요소를 찾으면 true값을 반환 후 반복 종료(찾는값이 없다면  undefined반환)
            boolean =a.find(function(item,index, array){
                console.log(item, index, array);
                if(item.id=='rlapwls2'){
                    return true;
                }

            })
            console.log(boolean);

            let filteredArray;
            //조건을 충족하는 요소가 있으면 해당 요소를 순차적으로 반환함.(하나도 없다면 빈 배열 반환)
            filteredArray = a.filter(function(item, index, array){
                //[] --> true값이 반환시 배열안에 현재 반복을 진행중인 요소가 추가됨.
                //요소.inclides("문자열") : 요소에 문자열이 포함되어 있는 경우 true/ 포함되지 않았다면 flase;
                if(item.id.includes("rlapwls")) {
                    return true;
                }
            })

            //화살표 함수로 축약시키기
            a.filter(item => item.id.includes("rlapwls"));
            //축악젼
            a.filter((item) => {
               return item.id.includes("rlapwls")
            });

        }
    </script>

    <hr>

    <h4>14)배열 변형(map)</h4>
    <p>
        현재 배열을 바탕으로 각 요소에 함수를 호출하여 내가 원하는 값으로 변경한 후 결과값을 반환함.
    </p>

    <button onclick="mapTest();">확인</button>
    <script>
        //map, filter, foreach : 많이 사용되는 메소드들
        function mapTest(){
            let result = [1,2,3,4,5];
            let mappedResult;

            mappedResult =result.map(function(item, index, array){

                return item*index; //return 시킨 값들이 배열아네 차곡차곡 쌓인 후 반환된다.
            })

            console.log(mappedResult);
        }
    </script>







































<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>